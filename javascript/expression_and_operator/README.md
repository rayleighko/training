## expression_and_operator   

[뒤로가기](/javascript/README.md)

#### 표현식은 자바스크립트 인터프티터가 값으로 평가하는 자바스크립트 구문이다.

복합표현식을 만드는 가장 쉬운 방법은 연산자를 사용하는 것이다.

###기본 표현식
```
2.1.23		//숫자 리터럴
"hello"		//문자열 리터럴
/pattern/  	//정규 표현식 리터럴


true, false		//불리언 값으로 평가된다.
null			//null 값으로 평가된다.
this			//'현재' 객체로 평가된다.

i				//변수 i의 값으로 평가된다.
sum				//변수 sum의 값으로 평가된다.
undefined		//undefined는 전역 변수로 null처럼 키워드가 아니다.
```

###객체와 배열의 초기화 표현식
```
[]			//빈 배열: 대괄호 안에 표현식이 없으면 원소가 없음을 말함.
[1+2,3+4]	//두 개의 원소를 가진 배열. 첫 번째는 3, 두번째는 7이다.

var martrix = [[1,2,3],[4,5,6],[7,8,9]];

var sparseArrey = [1,,,,5];

var p = { x:2.3, y:-1.2 };		//두 개의 프로퍼티를 가진 객체
var q = {};					//프로퍼티가 없는 빈 객체
q.x = 2.3; q.y=-1.2;			//객체 q와 p는 같은 프로퍼티를 갖는다.
```

###객체리터럴은 중첩될수 있다.
```
var side = 1;
var square = { 
	"upperLeft" : { x: p.x, y:p.y },
	"lowerRight": { x: p.x + side, y:p.y + side }
};
```

###함수 정의 표현식
함수 정의 표현식은 함수를 정의하고, 함수 정의 표현식의 값은 새로 정의된 함수다.
```
var square = function(x) { return x * x; }
```

###프로퍼티 접근 표현식
두가지 문법으로 프로퍼티에 접근할 수 있다.
**표현식 . 식별자**
**표현식 [ 표현식 ]**
```
var o = {x:1,y:{z:3}};		//간단한 객체 리터럴 예제
var a = [o,4,[5,6]];		//객체를 포함한 간단한 배열 리터럴 예제
o.x						//1
o.y.z						//3
o["x"]						//1
a[1]						//4
a[2]["1"]					//6
a[0].x						//1
```

###호출 표현식
```
f(0)				//f는 함수 표현식이다. 여기서 0은 인자 표현식이다.
Math.max(x,y,z)		//Math.max는 함수고, x,y,z가 호출 인자다.
a.sort()			//a.sortsms 함수고, 호출 인자가 없다.
```

###객체 생성 표현식
```
new Object()
```

**+ 연산자는 여러 문자열과 여러 숫자를 함께 사용할 때는 연산자 결합 법칙이 적용되지 않는다는 점을 반드시 기억해야 한다. 다시 말해, 연산자가 실행 된 순서에 따라 연산 결과가 달라질 수 있다는 의미다.**
```
1 + 2 + "blind mice";			//-> '3 blind mice'
1 + (2 + " blind mice");		//-> '12 blind mice'
```

###in 연산자
```
var point = { x:1, y:1 };		//객체 정의
"x" in point					//true 프로퍼티 x가 있다.
"y" in point					//false 프로퍼티 z가 없다.
"toString" in point			//true 상속된 프로퍼티
var data = [7,8,9];			//원소가 0,1,2 위치에 차례로 7,8,9
"0" in data					//0번째 원소가 있다.
1 in data						//1번째 원소가 있기 때문
3 in data						//3번째 원소가 없기 때문
```

#####instanceof 연산자
```
var d = new Date();		//Date() 생성자로 새로운 객체를 생성한다.
d instanceof Date();		//true: d는 Date()에 의해 생성되었다.
d instanceof Object();		//true: 모든 객체는 Object의 인스턴스.
d instanceof Number();		//false: d는 Number의 객체가 아니다.
```

#####void 연산자
voide는 단일 피연산자 앞에 쓰이는 단항 연산자로, 피연산자는 어떠한 타입도 될 수 있다. 이 연산자를 쓰는 목적은 좀 이례적이며, 사용 빈도가 낮다고 한다. 이 연산자는 피연산자를 무시하고 undefined를 반환하기 때문이다. void 연산자를 사용하면 피연산자 값이 버려지기 때문에, 피연산자가 부수 효과를 갖고 있을 때만 의미가 있다.
이 연산자의 가장 일반적인 사용처는 클라이언트 측 javascript: URL이다.

###문장

현제 단원과 관련은 많이 없지만 문장이라는 새로운 단원이 있었으나 현제 나에게 가장 익숙하고 많이 봐왔던것들이라 넘어갔지만, 중요한 것을 여기에 더 적어보려 한다.
### use strict
use strict는 ECMAScript 5에서 처음 소개된 지시어다. 지시어는 문장이 아니지만 여기서 설명한 use strict는 문장에 가깝다.
이 지시어는 일반적인 문장에는 크게 두가지 차이점이 있다.
```
1.어떤 자바스크립트 키워드도 포함하지 않는다. 지시어는 단순히 작은 따음표 또는 큰따음표로 둘러싸인 특정 문자열 리터럴로 구성된 표현문이다. ECMAScript 5 스펙이 구현되지 않은 자바스크립트 인터프리터는 부수 효과가 없는 표현문은 무시하므로 실행에 어떠한 영향도 미치지 않는다. ECMAScript 표준의 차기 버전에서는 use가 인용 부호 없이 실제 키워드로 바뀔 것 이다.
2.스크립트의 시작 부분이나 함수 몸체의 시작 부분에만 올 수 있으며, 다른 실제 실행문 앞에 오기만 하면 된다. 반드시 첫 문장일 필요는 없다. use strict앞 뒤에는 문자열 형태의 다른 표현문이 올 수도 있는데, 자바스크립트 구현체는 이 표현문들을 구현 종속적인 지시어로 받아들여 해석할 수 있도록 허용되어 있다. 스크립트나 함수의 첫 번째 일반 문장 다음에 오는 문자열 리터럴 표현문은 단순 표현문으로, 지시어로 해석되지도 않고 실행에 아무런 영향도 주지 않는다.
```

use strict지시어를 사용하는 목적은 지시어 다음에 오는 (스크립트나 함수의) 코드들이 엄격 모드를 따르게 하기 위해서다. 
```
엄격모드

코드에 더 나은 오류검사를 적용하는 방법이다. 이 모드를 사용하면 암시적으로 선언한 변수를 사용하거나 읽기 전용 속성에 값을 할당하거나 확장할 수 없는 개체에 속성을 추가할 수 없습니다.

ex)
"use strict";
function testFunction(){
	var testver = 4;
    return testvar;
}

//에러가 발생합니다.
testvar = 5;
```
이 처럼 스크립트 최상단에 'use strict' 지시어가 있으면 최상단 코드는 엄격한 코드다. 또한 엄격한 코드 안에 있거나, 몸체 시작 부에 'use strict' 지시어가 있는 함수의 몸체 코드는 엄격 코드다. 
eval()메서드에 전달되는 코드는, eval을 호출하는 코드가 엄격 모드를 따르거나, 전달된 코드 몸체에 'use strict'지시어가 있는 경우 엄격한 코드로 처리된다.

ECMAScript 5의 엄격 모드의 언어의 일부 기능이 제한된 부분 집함으로, 몇 가지 중요한 언어적 문제점을 수정하고 강력한 에러 검사와 향상된 보안 기능을 제공한다. (일반 모드와의 차이점이다.)
```
1.with 문은 엄격 모드에서는 사용할 수 없다.

2.엄격 모드에서 모든 변수는 반드시 선언되어야 한다. 선언되지 않은 변수나 함수, 함수 인자, catch 절 인자, 전역 객체 프로퍼티에 값을 할당할 경우 ReferenceError 예외가 발생한다.

3.엄격 모드에서 함수는 메서드로 호출된 것이 아닌, 함수로 호출된 함수의 this값은 undefined다. 
var hasStrictMode = (function() { "use strict"; return this === undefined } ());
또한 call()이나 apply()로 호출하면, this 값은 정확히 call() 이나 apply() 함수의 첫 번째 인자 값으로 설정된다.

4.엄격 모드에서는 writable 속성이 없는 프로퍼티에 값을 할당하거나, 확장할 수 없는 객체에 새 프로퍼티를 추가하려고 하면 TypeError 예외가 발생한다.

5.엄격 모드에서는 eval()의 인자로 전달된 코드는 eval() 호출자의 유효범위 안에 변수를 선언하거나 함수를 선언할 수 없다. eval 안에서 새로 선언한 변수나 함수는, 해당 eval을 위해 새로 만들어진 유효 범위 내에서만 유효하다.

6.이 유효범위는 eval()함수가 종료되면 사라진다.

7.엄격 모드에서 함수의 argument 객체는 함수에 전달된 값의 정적 사본을 가지고 있다. 하지만 표준모드에서 arguments 배열의 원소와 함수의 전달인자는 동일한 값을 참조한다.

8.엄격 모드에서는 delete 연산자 다음에 변수나 함수 또는 함수 전달인자와 같이 부적합한 식별자가 올 경우 SyntaxError 예외가 발생한다.(표준 모드에서는 이런 delete 표현식은 아무일도 일어나지 않고, false로 평가된다.)

9.엄격한 모드에서는 객체의 변경할 수 없는 프로퍼티를 지우려고 하면 TypeError 예외가 발생한다.

10.엄격 모드에서는 객체 리터럴에 같은 이름의 프로퍼티가 중복될 경우 문법 에러가 발생한다.

11.엄격 모드에서는 함수 선언에 같은 이름의 인자가 중복되면 문법 에러가 발생한다.

12.엄격 모드에서는 8진수 리터럴을 사용할 수 없다.

13.엄격 모드에서는 식별자 eval과 argument는 키워드로 취급되고,값을 바꿀수 없다. 또한 이러한 식별자에 값을 할당할 수 없고, 변수처럼 선언할 수 없으며 함수 이름이나 함수 전달인자 이름으로도 사용할 수 없다. 또한 catch블록에서 식별자로 사용할 수 없다.

14.엄격 모드에서는 호출 스택을 살펴보는 기능이 제한된다. arguments.caller와 argument.callee모두 엄격 모드에서는 TypeError예외를 발생시킨다. 엄격모드에서도 함수는 caller와 argument 프로퍼티를 갖긴 하지만, 막상 이들 프로퍼티를 읽으려고 하면 TypeError 예외가 발생한다.
```
