## regular_expression

[뒤로가기](/javascript/README.md)

정규 표현식(regular expression)은 문자의 패턴을 나타내는 객체다. 자바스크립트의 RegExp 클래스는 정규 표현식을 표현하고, String과 RegExp에는 정규 표현식을 사용하여 강력한 패턴 매칭을 수행하는 메서드와 텍스트상에서 특정 텍스트를 찾아서 바꾸는 함수가 정의되어 있다.

###정규 표현식 정의
자바스크립트에서 정규 표현식은 RegExp 객체로 표현된다. 물론 RegExp 객체는 RegExp() 생성자를 사용하여 만들 수 있지만, RegExp() 생성자보다는 정규 표현식 리터럴 문법이 더 자주 사용된다. 따음표 사이에 둘러싸인 문자들이 문자열 리터럴로 지정되는 것 처럼, 정규 표현식 리터럴은 항 쌍의 슬래시(/) 문자사이에 위치한 문자들이다. 따라서 정규 표현식에 대한 자바스크립트 코드는 다음과 같은 형태를 지닌다.
```
var pattern = /s$/;
```

이 코드는 새 RegExp 객체를 생성하고 이것을 변수 pattern에 할당한다. 이 RegExp 객체는 "s"로 끝나는 모든 문자열과 매치된다. 이 정규 표현식은 다음과 같이 RegExp() 생성자를 사용하여 정의한 것과 같다.
```
var pattern = new RegExp("s$");
```
정규 표현식 패턴은 연속된 문자로 구성되어 있다. 영숫자를 포함한 문자 대부분은 패턴에 적혀 있는 문자 그대로 매치된다. 따라서 정규 표현식 /java/는 문자열의 일부가 "java"인 모든 문자열과 매치된다. 몇몇 문자는 문자 그대로 매치되지 않으며, 특별한 의미를 지닌다. 예를 들어, 정규 표현식 /s$/는 두 문자로 구성되어 있는데, 먼저 s는 문자 그대로 s와 매치되고, 다음으로 $는 특수 메타 문자로 문자열의 끝과 매치된다. 따라서 이 정규 표현식은 s로 끝나는 모든 문자열과 매치된다.
다음 항목에서는 자바스크립트 정규 표현식에서 사용되는 다양한 문자와 메타 문자들을 살펴볼 것이다.
#####1. 리터럴 문자.
앞에서 언급했듯이 모든 영문자와 숫자는 그 문자 그대로 정규 표현식에서 매치된다. 특정한 비-알파벳 문자들은 역슬래시로 시작하는 이스케이프 문자열을 통해 지원한다. 예를 들면 \n은 문자열의 줄바꿈 문자와 매치된다. 
```
문자,숫자,영문자				->문자 그 자신
\0							->NUL 문자
\t							->탭
\n							->줄바꿈
\v							->수직 탭
\f							->폼 피드
\r							->캐리지 리턴
\xnn						->16진수 nn으로 명시도니 라틴 문자
\uxxx						->16진수 xxxx로 명시도니 유니코드 문자.
\cx							->제어 문자 ^X. 예로 \cJ는 줄바꿈 문자 \n과 같다.
```
몇 가지 구두점 문자는 정규 표현식에서 특별한 의미를 지닌다. 다음은 이러한 구두점 문자들이다.
```
^ $.*+?=!:|\/()[]{}
```
이 문자들의 의미는 다음 항목에서 다루며, 이문자 중 몇개는 오직 특정 정규 표현식 컨텍스트에서만 특별한 의미가 있고, 다른 컨텍스트에서는 보통의 리터럴로 취급된다. 그러나 일반적인 규칙은 만약 이러한 구두점 문자 중 어떤 것이라도 일반 문자로 취급하려면 반드시 \를 문자 앞에 붙여야 한다는 것이다.
만약, 어떤 구두점 문자를 역슬래시를 사용하여 이스케이프해야 하는지 정확히 기억하지 못한다면, 모든 구두점 문자 앞에 역슬래시를 붙여서 안전하게 처리할 수도 있다. 그러나 많은 글자와 숫자가 그 앞에 역슬래시가 놓이면 특별한 의미를 지닌다는 점을 유념하라. 따라서 글자 그대로 매칭되어야 하는 모든 글자와 숫자는 역슬래시를 사용하여 이스케이프되어서는 안 된다.
#####2. 문자 클래스
개별 리터럴 문자들은 그 문자들을 대괄호에 묶어서 문자 클래스로 다룰 수 있다. 문자 클래스는 해당 클래스 내의 모든 문자와 매치된다.
```
/[abc]/							->a,b,c 중 아무 글자에나 매치된다.
```
대괄호 안에서 캐럿(^)을 제일 앞에 두면 부정 문자 클래스를 정의할 수 있따.
```
/[^abc]/						->a,b,c를 제외한 모든 문자와 매치된다.
```
문자 클래스는 하이픈(-)을 사용하여 문자의 범위를 지정할 수도 있다. 따라서 라틴 알파벳 소문자와 매치되게 하려면/[a-z]/를 사용하고, 모든 라틴 알파벳 글자나 숫자와 매치되게 하려면/[a-zA-Z0-9]/을 사용하면 된다.
어떤 클래스들은 자주 사용되기 떄문에 자바스크립트 정규 푷션식 문법에는 자주 사용되는 문자 클래스를 나타내는 특수 문자와 이스케이프 문자열이 저으이되어 있다. \s는 스페이스 문자와 탭문자, 다른 모든 유니코드 공백 문자와 매치된다. \S는 유니코드 공백문자를 제외한 모든 문자와 매치된다.
이스케이프된 특수 문자 클래스를 대괄호 내에서 사용할 수 있다는 점을 눈여겨보라. \s는 모든 공백 문자와 매치되고 \d는 모든 숫자와 매치된다. 따라서 /[\s\d]/는 공백 문자 하나 또는 숫자 문자 하나와 매치된다.
그러나 한가지 특별한 경우가 있다. 다음에 살펴보는 \b는 별도의 특별한 의미를 지니고 있따. 그러나 문자 클래스 내에서 사용되면 백스페이스 문자를 나타내는다. 따라서 정규 표현식에 백스페이스 문자 자체를 표현하려면 다음과 같이 하나의 요소만 있는 문자 클래스를 사용해야 한다. /[\b]/
```
[...]								->대괄호 사이에 있는 한 문자.
[^...]								->대괄호 사이에 없는 한 문자.
.									->줄바꿈 문자나 유니코드 라인 종류 문자를 제외한 모든 문자.
/w									->ASCII 워드 문자. [a-zA-Z0-9]와 동등
/W									->ASCII 워드 문자가 아닌 모든 문자 [^a-zA-Z0-9_]와 동등하다.
/s									->모든 유니코드 공백 문자.
/S									->유니코드 공백 문자가 아닌 모든 문자. 하지만 /w와 /S는 같지 않다.
/d									->모든 ASCII 숫자, [0-9]
/D									->ASCII 숫자가 아닌 모든 문자. [^0-9]와 동등하다.
[\b]								->백스페이스 리터럴(특수경우)
```
#####3.반복
지금 까지것을 모두 사용하면 두 자리 숫자 /\d\d/로, 네 자리 숫자를 /\d\d\d\d/로 표현할 수 있다. 그러나 임의 자리의 수 또는 세개의 문자가 있고 뒤이어 생략 가능한 숫자로 이루어진 문자열을 표현하기는 어려울 것이다. 이런 복잡한 패턴을 작성할 때는 정규 표현식의 요소가 몇 번이나 반복되는 지를 나타내는 문법을 사용해야 한다.
반복을 지정하는 문자는 언제나 반복을 지정할 패턴 뒤에 나온다. 어떤 종류의 반복은 매우 자주 사용되기 때문에, 이런 반복을 표현하는 몇 가지 특수 문자가 있다.
```
/\d{2,4}/							->두 자리에서 네 자리의 숫자와 매치된다.
/\w{3}\d?/							->정확히 세 개의 문자와 생략 가능한 숫자와 매치된다.
/\s+java\s+/						->java와 앞뒤로 하나 이상의 공백 문자를 포함한 문자열과 배치된다.
/[^(]*/								->시작 괄호가 아닌 0개 이상의 문자와 매치된다.
```
*와 ? 반복문자를 사용할 때는 조심해야 한다. 이 문자들은 그 앞에 오는 문자가 무엇이든 간에 0번 매치된다고 간주하기에, 반복 문자열 앞의 문자가 매치되지 않는 상황도 허용한다. 예를 들어 정규 표현식 /a*/는 실제로 문자열 bbbb와 매치되는데, 이는 이 문자열에 a가 0번 나타나기 때문이다.
```
{n,m}						->앞의 항목이 적어도 n번 이상, m번 이하로 나타난다.
{n,}						->앞의 항목이 n번 이상 나타난다.
{n}							->앞의 항목이 정확하게 n번 나타난다.
?							->앞의 항목이 항목이 0 또는 한 번 나타난다. 즉, 앞의 항목이 나오지 않을 수도 있다.{0,1}과동등
+							->앞의 항목이 한 번 이상 나타난다. {1,}과 동등하다.
*							->앞의 항목이 0번 또는 그 이상 나타난다.{0,}과 동등하다.
```
######비탐욕적 반복
정규 표현식 /a+/는 한 개 이상의 a와 매치되는데, 이 정규 표현식을 "aaa"에 적용하면 세 문자 모두와 매치한다. 그러나 /a+?/는 매칭에 필요한 a가 한 번 이상나타나더라도, 최소한의 글자만 매칭한다. "aaa"에 이 정규 표현식을 적용하면 오직 첫 번째 글자"a"만 매치된다.
비탐욕적 반복이 언제나 기대한 결과를 가져오지는 않는다. /a+b/ 패턴은 하나 이상의 a와 그다음에 b가 나타나는 경우와 매치한다. 이 패턴이"aaab"문자열에 적용되면 이 정규 표현식은 전체 문자열과 매치된다. 이제 비탐욕적 정규 표현식/a+?b/를 살펴보자. 이 정규 표현식은 가능한 적은 수의 a와 b 한 문자를 매치한다. 이 정규 표현식을 같은 문자열 "aaab"에 적용했을 때, 아마도 오직 하나의 a와 마지막 글자 b에 매치되기를 기대하겠지만 사실 이 패턴은 탐욕적 정규 표현식과 마찬가지로 문자열 전체와 매치된다.
왜냐하면 매칭이 가능한 첫번째 위치부터 매치해 나가기 때문이다. 이 경우 문자열의 첫 번째 문자부터 매칭이 가능하므로, 이후의 문자로부터 시작하는 더 짧은 매치는 전혀 고려되지 않는다.
#####4.대체, 그룹화, 참조
정규 표현식 문법은 대체 표현식, 부분 표현식 그룹화, 이전 부분 표현식을 참조하는 특별한 문자를 포함하고 있다. 파이프 문자(|)는 대체 표현식을 구분한다. 예를 들어 /ab|cd|ef/는 문자열 "ab"또는 문자열 "cd"또는 문자열"ef"와 매치된다. 그리고  /\d{3}|[a-z]{4}/는 세자리 숫자 문자열 또는 네개의 소문자로 이루어진 문자열과 매치된다.
/a|ab/는 오직 첫 번째 글자 a만 매치된다.
정규 표현식에서 괄호는 여러 목적으로 사용된다. 하나는 여러 항목을 하나의 부분 표현식으로 묶고(그룹화), 이렇게 묶인 항목들은 |,*,+,?등이 하나의 단위로 취급할 수 있도록 하는 것이다. 예를 들어 /java(script)?/는 java와 그 다음에 생략 가능한 script가 오는 문자열과 매치된다. 그리고 /(ab|cd)+|ef/는 ab또는 cd가 한번 이상 반복되는 문자열 호긍ㄴ 문자열 ef와 매치된다.
정규 표현식에서 괄호의 다른 목적은 전체 패턴 안에 부분 패턴을 정의하는 것이다. 예를 들어 한 개 이상의 소문자와 뒤따르는 한 자리 이상의 숫자를 찾는다고 가정하자. 이 경우 /[a-z]+\d+/ 패턴을 사용할 수 있따. 만약 각 매치에 대해 끝에 있는 숫자에만 관심이 있다고 가정하면, 패턴 일부를 /[a-z]+(\d+)/와 같이 괄호 안에 두고 찾아낸 매치 결과에서 숫자를 추출할 수 있다.
괄호로 둘러싸인 부분 표현식을 사용하면 같은 정규 표현식 내에서 해당 부분을 다시 참조할 수 있따. \문자뒤에 숫자를 두면 된다. 예를 들면 \1은 첫 번째 부분 표현식을 참조하고 \3은 세 번째 부분 표현식을 참조한다. 부분 표현식은 서로 중첩될 수 있기 때문에, 이 숫자는 왼쪽 괄호가 나타내는 순서임을 주의하라. 예를 들어 다음 정규 표현식에서 중첩된 부분 표현([Ss]cript)는 \2로 참조된다.
```
/([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/
```
부분 표현식에 대한 참조는 부분 표현식의 패턴이 아닌, 패턴과 매치되는 텍스트를 참조한다. 따라서, 문자열 내의 여러 부분이 정확히 같은 문자들을 포함하도록 제약할 수 있다. 예를 들어, 다음 정규 표현식은 작은따음표나 큰 따음표 사이에 한 개 이상의 문자가 있다면 매치된다. 그러나 처음 따음표와 끝 따음표가 매치될 필요는 없다.
```
/['"][^'"]*['"]/
```
따음표가 서로 매치되게 하려면 참조를 사용해야 한다.
```
/(['"])[^'"]*\1/
```
/1은 첫 번째 골호로 둘러싸인 부분 표현식이 매치된 텍스트다. 이 예제에서 \1은 끝 따음표가 처음 따음표와 매치되도록 제약을 둔다. 이 정규표현식은 작은 따음표가 큰 따음표 사이에 잇는 경우는 허용하지 않는다. 아울러, 문자 클래스 내에서는 참조를 사용할 수 없기 떄문에 다음과 같이 해서는 안된다.
```
/(['"])[^'"]\1/
```
참조를 만들지 않고 항목을 그룹화하려면 (와 )를 사용하는 대신, (?:을 사용하여 그룹을 시작하고 ) 로 끝낸다.
```
/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/
```
여기서 부분 표현식(?:[Ss]cript)이 그룹화를 위해 사용되었고, 따라서 반복문자 ?는 이 그룹ㅇ 적요될 수 잇다. 따라서 이 정규 표현식에서 \2는 (fun\w*)와 매치되는 텍스트를 참조한다.
```
|			->대체. 왼쪽에 있는 부분 표현식이나 오른쪽에 있는 부분 표현식중 하나를 매치한다.
(...)		->그룹화. 하나의 단위로 그룹화된 아이템으로 *,+,?,|등에 의해 사용될 수 있다.
				또한, 나중에 이 그룹의 항목들은 하나의 단위로 취급되지만, 이 그룹에 매치되는 문자들을 기억하지 않는다.
(?:...)		->그룹화만 한다. 그룹의 항목들은 하나의 단위로 취급되지만, 이 그룹에 매치되는 문자들을 기억하지는 않는다.
\n			->n번째 그룹이 처음 매치했던 문자와 같은 문자를 매치한다. 그룹은 괄호로 둘러싸인(중첩될 수 있는)부분표현식이다.
				그룹 번호는 시작 괄호를 왼쪽부터 오른쪽으로 세는 것에 의해 할당된다.(?:형태의 그룹은 세지 않는다.)
```
#####5.매치 위치 지정
앞서 설명한 것처럼 정규 표현식의 많은 요소는 문자열 내의 하나의 문자와 매치된다. 예를 들면 \s는 하나의 공백 문자와 매치된다. 그러나 어떤 요소는 실제 문자 대신 문자와 문자 사이의 위치와 매치된다. 예를 들어 \b는 단어 경제에 매치되고, 이 경계는 \w(ASCII 단어 문자)와 \W(비단어 문자) 사이의 경계 혹은 ASCII단어 문자와 문자열의 시작 또는 끝의 경계를 의미한다. \b와 같은 요소는 매치에 사용할 문자를 지정하지 않고 매치가 일어날 수 있는 적절한 위치를 지정한다. 때때로 이 요소들을 정규 표현식 앵커라고 하는데, 이는 이 요소들이 검색할 문자열의 특정 위치에 정규식을 고정할 수 있기 때문이다. 일반적으로 가장 많이 사용하는 앵커 요소는 문자열의 시작 부분에 정규식을 고정 하는 ^와 문자열의 마지막에 정규식을 고정하는 $이다.
예를들어 JavaScript라는 단어 자체로 한 줄인 문자열을 매치하려면 /^JavaScript$/ 정규 표현식을 사용할 수 있다. Java라는 단어 자체를 찾으려면, 앞뒤로 공백이 있는 /\sJava\s/와 같은 패턴을 시도해볼 수 있다. 그러나 이 방법에는 문제점이 있다. 하나는 Java가 문자열의 시작이나 끝에서는 매치되지 않고, 오직 양쪽에 실제 공백 문자가 있는 경우에만 매치된다는 점이다. 다른 문제점은 이 패턴을 사용하여 매치되는 부분을 찾으면, 매치 결과에는 실제로는 불필요한 앞뒤 공백이 들어가 있다는 점이다. 따라서 \s 대신, \b를 사용하여 단어 경계를 매치(혹은 고정) 하라. 이에 대한 정규 표현식은 /\bJava\b/이다. 요소 \B는 단어 경계가 아닌 곳에 정규식을 고정한다. 따라서 패턴 /\B[Ss]cript/는 JavaScript와 postscript에 매치하지만, script나 Scripting과는 매치하지 않는다.
또한, 임의의 정규 표현식을 앵커 조건으로 사용할 수 있다. 만약 (?=와 ) 문자 사이에 표현식이 있으면 이는 그정형 전방 탐색 선언문이고, 이는 (?= 와 )사이에 있는 문자들이 반드시 매치되어야 한다는 의미지만, 매치된 문자열이 결과에 포함되지는 않는다는 뜻이다. 예를 들어 프로그래밍언어  다음에 클론이 따르는 경우를 매칭시키려면 /[Jj]ava([Ss]cript)?(?=\:)/을 사용할 수 있다. 이 패턴은 JavaScript: The Definitive Guide의 JavaScript에 매치되지만 Java in a Nullshell의 Java는 콜론이 없기에 매치되지 않는다.
만약 (?!를 사용하여 선언문을 만들면, 이는 부정형 전방 탐색이고, 그다음에 나오는 문자열들이 매치되면 안된다는 뜻이다. 예를 들어 /Java(?!Script)([A-Z]\W*)/는 Java와 그다음에 한 대문자와 임의 개수의 ASCII 문자들이 오는 경우를 매치하지만 Java 그다음에 Script가 오는 경우는 매치하지 않는다. 이 정규식은 JavaBeans와 매치되지만 Javanese와는 매치되지 않고, JavaScript나 JavaScripter와도 매치되지 않는다.
```
^			->문자열의 시작 부분, 정규식이 여러 줄을 대상으로 할는 경우 한 줄의 시작과 일치한다.
$			->문자열의 끝을 나타낸다. 여러 줄일 경우 한줄의 마지막을 나타낸다.
\b			->단어 경계를 나타낸다. 즉 \w와 \W문자 사이, 혹은 \w문자와 문자열의 시작 또는 끝과 일치한다.
				([\b])는 백스페이스를 나타내니 주의하라.
\B			->단어 경계가 아닌 곳의 위치를 나타낸다.
(?=p)		->지방 탐색 선언. (?= 다음에 나오는 문자들은 패턴 p와 매치되어야 한다. 그러나 매치 결과에는 포함되지 않는다.
(?!p)		->부정형 전방 탐색 선언. (?! 다음에 나오는 문자들은 패턴 p와 매치되지 않아야 한다.
```
#####6.플래그
정규 표현식 플래그는 고 차원 패턴 매칭 규칙을 지정한다. 다른 정규 표현식 문법과는 달리 플래그 /문자 쌍 바깥에, 즉 두번째 슬래시 다음에 등장한다. 자바스크립트 세 가지 플래그를 지원한다.
i 플래그는 대소문자를 구별하지 않고 패턴 매칭이 되어야 한다는 의미다.
g 플래그는 전역 패턴 매칭을 지정하는데, 즉 검색할 문자열 내에서 패턴의 첫 번째 매칭 결과 뿐만 아니라 모든 매칭 결과를 얻는다.
m 플래그는 여러 줄에 걸쳐 패턴매칭을 수행한다. m플래그를 지정한 상태에서 검색될 문자열이 줄바꿈 문자를 포함하고 있으면, ^와 $앵커는 문자열의 시작과 끝을 나타낼 뿐만 아니라 각 줄의 시작과 끝을 나타내기도 한다. 예를 들어 패턴 /java$/im은 java뿐만 아니라 java\nis fun에도 매치된다.
이 플래그들은 조합하여 지정될 수 있다 예를 들어 대소문자를 구별하지 않고 java 문자열을 찾으려면, 대소문자를 구별하지 않는 정규 표현식 /\bjava\b/i를 사용할 수 있다. 그리고 문자열에서 이단어가 나오는 모든 부분을 찾으려면 g플래그를 추가하면 된다.
```
/\bjava\b/gi
```
```
i			->대소문자를 구별하지 않는 매칭을 수행한다.
g			->전역 매칭을 수행한다. 즉, 처음 매치에서 끝내지 않고 모든 매치를 찾는다.
m			->여러 줄 모드. ^은 줄의 시작이나 문자열의 시작과 일치하고, $는 줄의 끝이나 문자열의 끝과 일치한다.
```
###패턴 매칭을 위한 문자열 메서드
여기서는 패턴 매칭 및 '검색 후 바꾸기' 수행을 위해 정규 표현식을 사용하는 String 객체의 메서드에 대해 논의할 것이다. 다음 절에서는 RegExp 객체의 메서드와 프로퍼티를 다루면서 자바스크립트 정규 표현식을 사용한 패턴 매칭에 대한 논의를 계속 할 것이다. 다음에 다루는 내용은 단지 정규 표현식과 관련된 여러 메서드와 프로퍼티에 대한 개요 일뿐 아니라는 점을 유념하라.
문자열에는 정규 표현식을 사용하는 메서드가 네 개 있다. 가장 간단한 것은 search()메서드다. 이 메서드는 정규 표현식을 인자로 받고, 가장 처음 매칭되는 부분 문자열의 위치를 반환한다. 만약 매칭되는 부분 문자열이 없다면 -1 을 반환한다. 예를 들어 다음 코드는 4를 반환한다.
```
"JavaScript".search(/script/i);
```
만약 search()에 넘기는 인자가 정규 표현식이 아니라면, 이 인자는 먼저 RegExp생성자로 넘겨지고 정규 표현식으로 변환된다. search()는 전역 검색을 지원하지 않기 때문에, 정규 표현식 인자는 g플래그는 무시된다.
replace() 메서드는 검색 후 바꾸기를 수행한다. g플래그가 포함되어 있다면 replace()메서드는 문자열에서 매치되는 모든 부분을 지정된 문자열로 바꾼다.g 플래그가 없다면 처음 매치되는 문자열만 바꾼다. replace()의 첫 번째 인자가 정규 표현식이 아니라 일반 문자열인 경우 RegExp() 생성자를 사용하여 정규 표현식으로 변환하지 않고 전달된 문자열을 문자열 그대로 찾는다. 이는 search()와 반대다. 예를 들면 텍스트상에서 JavaScript라는 단어를 찾아 대소문자를 다듬으려면 다음과 같이 replace()메서드를 사용할 수 있다.
```
//원래 문자열의 대소문자가 어떻게 구성되었는지 간에, 대소문자를 다듬는다.
text.replace(/javascript/gi, "JavaScript");
```
그러나 replace()는 이보다 강력하다. 괄호로 둘러싸인 부분 표현식은 왼쪽에서 오른쪽으로 번호가 매겨지고, 각 부분 표현식이 매치된 텍스트를 찹조한다고 했던 것을 기억할 것이다. 만약 교체할 문자열의 $ 다음에 숫자가 나오면 replace()는 이 두 문자를 해당 번호가 가리키는 부분 표현식에 매치된 텍스트로 바꾼다. 이는 매우 유용한 기능인데, 예를 들어 일반 따움표를 굽은 따움표로 바꾸려면 다음과 같이 하면 된다.
```
//quote는 인용 부호와 인용 부호가 아닌 임의 개수의 문자.
//그리고 인용 부호가 오는 정규 표현식이다.
var quote = /"([^"]*)"/g;
//인용 부호를 굽은 따음표로 바꾼다. 인용 부호 내의 텍스트($1에 저장된)는 바뀌지 않는다.
text.replace(quote, '"$1"');
```
가장 특별한 것은 replace()의 두 번째 인자는 교체될 문자열을 동적으로 계산하는 함수가 될 수 있다는 것이다.
String에서 정규 표현식을 사용하는 메서드 중 match() 메서드는 가장 일반적으로 사용된다. match() 메서드는 오직 정규 표현식 하나만을 인자로 받고(정규 표현식이 아닐 경우에는 RegExp() 생성자에 인자를 전달하여 정규 표현식으로 변환한다.)매치 결과를 배열로 반환한다. 만약 정규 표현식에 g 플래그가 설정되어 있으면, match() 메서드는 문자열 내의 모든 매치 부분을 배열로 반환할 것이다.
```
1 plus 2 equals 3".match(/\d+/g)			-> ["1","2","3"]을 반환한다.
```
g플래그가 설정되어 있지 않으면, match()는 전역 검색을 수행하지 않고 단순히 첫 번째 매칭만 찾는다. 그러나 match()는 전역 검색을 수행하지 않더라도 매치 결과는 배열로 반환한다.
```
var url = /(\w+):/\/\([\w.]+)\/(\S*)/;
var text = "Visit my blog at http://www.example.com/~david";
var result = text.match(url);
if (result != null) {
	var fullurl = result[0];			->"http://www.example.com/~david"가 저장되어 있다.
    var protocol = result[1];			->"http"가 저장되어 있다.
    var hos = result[2];				->"www.example.com"이 저장되어 있따.
    var path = result[3];				->"~david"가 저장되어 있다.
}
```
문자열의 match() 메서드에 g플래그가 없는 비전역 정규 표현식을 전달하는 것은 실질적으로 정규 표현식의 exec() 메서드에 문자열을 전달하는 것과 같다. match() 메서드가 반환한 배열에는 exec()메서드가 반환한 것과 마찬가지로 index와 input 프로퍼티가 있다.
split() 메서드는 주어진 인자를 구분자로 삼아 메서드가 호출된 문자열을 부분 문자열로 쪼갠다.
```
"123,456,789".split(",") 		->["123","456","789"]을 반환한다.
```
aplit()메서드 또한 정규 표현식을 인자로 받을 수 있다. 이는 메서드를 더욱 강력하게 만들어 준다. 예를 들면 다음과 같이 양쪽에 임의 개수의 공백이 있는 구분자를 지정할 수 있다.
```
"1, 2, 3, 4, 5".aplit(/\s*,\s*/);		->["1","2","3","4","5"]를 반환한다.
```
###RegExp 객체
정규 표현식은 RegExp 객체로 표현된다. RegExp() 생성자 외에도 RegExp 객체는 세 가지 메서드와 몇 개의 프로퍼티를 지원한다.
RegExp() 생성자는 하나 또는 두 개의 문자열을 인자로 받고 새로운 RegExp 객체를 생성한다. 이 생성자에 전달되는 첫 번째 인자는 정규표현식의 본문(정규 표현식 구문에서 두 슬래시 사이에 있는 텍스트)이다. 문자열 리터럴과 정규 표현식 모두 이스케이프 문자로 역슬래시 \를 사용한다는 것을 유념할 필요가 있고, 따라서 RegExp() 생성자에 정규 표현식을 문자열 리터럴로 전달하려면, 각 \ 문자를 \\로 바꾸어야 한다. RegExp() 생성자의 두 번째 인자는 생략할 수 있다. 만약 인자를 지정하려면 이는 정규표현식 플래그여야 하고 g,i,m 또는 이 문자들의 조합이어야 한다.
```
//문자열에서 다섯 자리 숫자를 모두 찾는다. 역슬래시를 두 번 사용한 것을 주목하자.
var zipcode = new RegExp("\\d{5}", "g");
```
RegExp() 생성자는 동적으로 정규 표현식을 생성해야 할 때, 즉 리터럴 문법으로 정규 표현식을 표현할 수 없을 때 유용하다. 예를 들어 사용자가 입력한 문자열에 대해 검색을 하려면, 정규 표현식은 RegExp() 를 사용하여 실행 중에 생성되어야 한다.
#####1. RegExp 프로퍼티
RegExp 객체에는 다섯 개의 프로퍼티가 있다.
1. source 프로퍼티는 정규 표현식의 텍스트를 저장하는 읽기 전용 문자열이다.
2. global 프로퍼티는 읽기 전용 불리언 값으로 정규 표현식에 g플래그가 있는지를 나타낸다.
3. ignoreCase 프로퍼티는 읽기 전용 불리언 값으로 정규 표현식이 i 플래그를 가지고 있는지 여부를 나타낸다.
4. multiline 프로퍼티는 읽기 전용 값으로 정규 표현식에 m플래그가 있는지를 나타낸다.
5. lastIndex 프로퍼티는 읽고 쓸 수 있는 정수 값이다. g플래그를 사용한 정규 표현식에 대해, latsIndex 프로퍼티는 문자열의 어느 위치에서 다음 검색이 시작되는지를 지정한다.

#####2. RegExp 메서드
RegExp 객체에는 패턴 매칭을 수행하는 두 메서드가 있고, 이 메서드는 앞에서 설명한 String의 메서드와 비슷하게 작동한다. RegExp에서 가장 중요한 메서드는 exec()이다. 이는 match() 메서드와 비슷한데, String의 match 메서드가 RegExp를 인자로 받는 것과 달리 문자열을 인자로 받는다. exec()메서드는 주어진 문자열에 대해 정규 표현식을 실행한다. 즉, 주어진 문자열에서 매치되는 부분을 찾는다. 만약 매치되는 부분을 찾지 못했다면 null을 반환한다. 그러나 만약 매치되는 부분을 찾았다면 매칭 결과를 저장한 배열을 반환한다.
match()메서드와 달리, exec() 메서드는 정규 표현식에 전역 g 플래그가 있건 없건 상관없이 같은 종류의 배열을 반환한다. match() 메서드가 전역 정규표현식을 전달 받았을때 매치 결과 배열을 반환한다는 것을 떠올려보라. 이와 대조적으로 exec()는 언제나 하나의 매치 결과만 반환하고, 해당 매치에 대한 전체 정보를 제공한다. 만약 g 플래그가 있는 정규 표현식 상에서 exec()가 호출되면, 정규 표현식 객체의 lastIndex 프로퍼티는 현재 매치된 부분 문자열의 바로 다음 문자 위치로 설정된다. 같은 정규 표현식에 대해 exec()를 다시 호출하면, lastIndex 프로퍼티가 가리키는 문자 위치부터 검색을 시작한다. 만약 매치되는 부분을 발견하지 못하면 lastIndex 프로퍼티는 0으로 재설정될 것이다.
이 특수한 방식 때문에 한 문자열에서 모든 정규 표현식 매칭을 찾으려면 exec() 여러 번 호출해야 한다.
```
var pattern = /Java/g;
var text = "JavaScript is more fun than Java!";
var result;
while((result = pattern.exec(text)) != null) {
	alert("matched '" + result[0] + "'" + " at position " + result.index +
    		"; next search begins at " + pattern.lastIndex);
}
```
RegExp의 다른 메서드는 test()다 test()는 exec()보다 단순하다. 문자열을 인자로 받고 만약 문자열에 정규 표현식과 매치되는 부분이 있다면 true를 반환한다.
```
var pattern = /java/i;
pattern.test("JavaScript");				-> true를 반환
```
String의 search(),replace(),match() 메서드는 lastIndex 프로퍼티를 exec()와 text() 처럼 사용하지 않는다. 사실 String의 메서드들은 단순히 lastIndex를 0으로 설정할 뿐이다. 만약 g 플래그가 설정된 하나의 정규식 객체의 exec()나 test()를 사용하여 여러 개의 문자열을 검색하려 한다면, 다른 문자열을 검색하기 전에 이전의 문자열에서 매치되는 모든 부분을 찾아야 한다.