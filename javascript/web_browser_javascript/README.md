## web_browser_javascript

[뒤로가기](/javascript/README.md)

웹브라우저에서 사용하는 자바스크립트에 대해 알아보자.

이번 문서는 **자바스크립트의 컨텍스트**에 대해 알아본다.

자바스크립트에 대한 이야기를 하기 전에, 웹브라우저에서 보이는 웹 페이지를 생각해보자.

정적인 정보를 제공하는 페이지는 문서라고 부른다. 하지만, 문서가 아니라 **애플리케이션** 같은 웹 페이지도 있다. 
이런 페이지는 새로운 정보를 필요할 때 동적으로 불러오고, 텍스트보다 그래픽 요소가 많다. 그리고 오프라인에서 작동하거나, 재방문할 때 페이지의 내용을 복구할 수 있도록 로컬에 정보를 저장할 수도 있다. 그리고 어떤 웹 페이지는 문서와 애플리케이션 영역 사이에서 문서와 애플리케이션의 특징을 모두 겸비한다.

#####클라이언트 측 자바스크립트

Window 객체는 클라이언트 측 자바스크립트의 기능과 API에서 핵심적인 진입점이다. 이 객체는 웹브라우저의 창이나 프레임을 나타내고, 특정 창을 Window 객체로 참조할 수 있다. Window 객체는 location과 같은 프로퍼티들을 제공하는데, location프로퍼티는 Location 객체를 가리킨다.

>//새로운 웹 페이지로 보내기 위해 location 프로퍼티에 값을 지정.
>window.location = "http://www.oreilly.com/";

>2초 후에 hello world 메세지 노출.
>setTimeout(function() { altert("hello world"); }, 2000);

앞코드에서 명시적으로 window가 사용되지 않았음을 주의 해야한다.

Window 객체의 가장 중요한 프로퍼티 중 하나인 document는 창에 표시된 내용에 해당하는 Document 객체를 참조한다.
>//id가 "timestamp"인 요소를 찾는다.
>var timestamp = document.getElementById("timestamp");

getElementById()가 반환하는 Element 객체에는 내용을 가져오고 속성값을 지정할 수 있는 또 다른 주요 프로퍼티와 메서드가 존재한다.
>//요소가 비어 있다면 이 안에 최근 날짜와 시간을 넣는다.
>if (timestamp.firstChild == null)
> timestamp.appendChile(document.createTextNode(new Date().toString()));

Element 객체는 style과 className이라는 프로퍼티를 이용해서 CSS 스타일을 지정하거나 적용할 CSS클래스 명을 변경할 수 있다.
>//다루고 있는 요소의 표현방식을 명시적으로 변경한다.
>timestamp.style.backgroundColor = "yellow";
>//또는 클래스만 변경한다. 그리고 상세한 정의는 스타일시트에 둔다.
>timestamp.className = "highlight";

이벤트 핸들러 프로퍼티도 Window,Document,Element 객체의 중요한 프로퍼티인데, 어떤 이벤트가 발새앟ㄹ 때 비동기로 호출할 함수를 지정할 수 있다.
>//사용자가 클릭하면 timestamp 요소의 내용을 갱신한다.
>timestamp.onclick = function() { this.innerHTML = new Date().toString(); }

#####웹 문서의 자바스크립트
컨테이너 역할을 하는 Document 객체와 Element객체를 통해서 자바스크립트 프로그램은 문서 내용을 탐색하고 조작할 수 있다.
CSS의 스타일과 클래스를 사용하여 내용을 표현하는 방식을 변경할 수 있고, 적절한 이벤트 핸들러를 등록해서 document 요소의 동작을 정의할 수 있다. 
스크립팅 가능한 내용과 표현, 동작을 모두 합쳐서 동적 HTML 또는 DHTML이라 한다.

#####웹 애플리케이션의 자바스크립트
웹 애플리케이션은 웹 문서의 자바스크립트 DHTML을 모두 사용할 뿐만 아니라, 이를 넘어서서 웹브라우저 환경이 제공하는 내용과 표현, 행위를 조작하는 API 등등의 핵심 부가 서비스를 제공한다.
웹 애플리케이션을 확실히 이해하려면, **간단한 운영체제로 탈바꿈** 했음을 깨우쳐야 한다.

마음속으로 웹브라우저가 간단한 OS임을 인식한다면, 우리는 브라우저가 제공하는 확장된 서비스를 이용하기 위해 자바스크립트를 사용한 웹 애플리케이션이라고 정의할 수 있다ㅏ.
확장 서비스중 가장 유명한 것은 XMLHttpRequest 객체다.

#####HTML 안에 자바스크립트 포함하기
클라이언트 측 자바스크립트를 HTML문서 안에 내장하는 방법은 네가지 이다.
1. script 태그와 /script 태그 안에 직접 작성
2. script 태그의 src속성에 별도 파일로 정의
3. onclick 이나 onmouseover 같은 HTML 이벤트 핸들러 속성 안에 작성.
4. javascript:라는 특별한 프로토콜을 사용해서 URL안에 작성.

**비간섭 자바스크립트** 라고 알려진 프로그래밍 철학은, 내용(HTML)과 동작(javascript)을 최대한 분리해야 한다고 말한다. 이 철학을 따르는 최고의 방법은 script 태그에 src 속성을 지정하는 방법이다.

###### 1. script요소에 직접작성
```
<script>
//자바스크립트 코드를 여기에 작성
</script>
```
예제
```
<!DOCTYPE html>
<html>
	<head>
    	<title>디지털시계</title>
        <script>
        	function displayTime() {
            	var elt = document.getElementById("clock");
                var now = new Date();
                elt.innerHTML = now.toLocaleTimeString();
                setTimeout(displayTime, 1000);
            }
            window.onload = display.Time;
        </script>
        <style>
        	#clock {
            	font: bold 24pt sans;
                background: #ddf;
                padding: 10px;
                border: solid black 2px;
                border-radius: 10px;
            }
        </style>
    </head>
    <body>
    	<h1>디지털 시계</h1>
        <span id="clock"></span>
    </body>
<html>
```

######2.외부 파일 스크립트
```
<script src="../../script/util.js"></script>
```
util.js 파일에는 순수하게 자바스크립트만 있어야 한다. 즉, 파일 내에 script 태그 또는 HTML 같은 것이 없어야 한다. 자바스크립트 파일의 확장자는 관습적으로 .js를 사용한다.

src 속성을 사용하면 script 태그 사이에 어떤 내용을 넣어도 무시된다.

######src 장점
1. 코드상의 자바스크립트 영역 제거로 HTMl파일 간단
2. 여러 웹 페이지가 자바스크립트 코드 공유할때 소스만 유지하여 코드가 바뀔때 마다 여러 HTML 파일을 일일이 수정하지 않아도 된다.
3. 한꺼번에 내려받을수 있다.
4. src속성값은 임의의 URL이기 떄문에 어떤 서버의 자바스크립트 프로그램이나 웹 페이지는 다른 웹 서버에서 출력되는 코드를 사용할 수 있다. 많은 광고가 이 기법을 사용한다.
5. 다른 사이트의 스크립트를 불러오는 것은 좀 더 넓은 의미의 캐싱 효과와 같다.

스크립트 파일의 위치가 아니라 스크립트를 내장한 문서의 위치가 중요하다는 것에 주의해야 한다. 문서와 스크립트가 다른 도메인에 있어도, 문서에 내장된 스크립트와 상호작용이 가능하며, 이경우에는 동일 출처 정책이 적용되지 않는다.

######3. 스크립트 타입
웹 스크립트의 원조이며 script요소는 기본적으로 자바스크립트 코드를 참조하고 내장하는 일을 맡는다.
```
<script type="text/vbscript">
	VBScript코드를 여기에 적는다.
</script>
<script languge="javascript">
	//Javascript코드....
</script>
```

#######4.HTML 안의 이벤트 핸들러
HTMl에 포함된 자바스크립트 코드는 웹브라우저가 HTML 파일을 불러올 때 한 번 실행된다.
```
<input type="checkbox" name="option" value="giftwrap" onchange="order.option .giftwrap = this.checkedl;">
```
중요한건 onchange 속성이다.
브라우저는 사용자가 체크박스를 체크하거나 체크를 해제할 때마다 onchange속성에 지정된 자바스크립트 코드를 실행한다.

######5. URL 안의 자바스크립트
자바스크립트 코드를 클라이언트 측에 넣는 또 다른 방법은 javascript: 프로토콜 지시자로 시작하는 URL 안에 두는 것이다.
```
<a href="javascript:new Date().toLocaleTimeString();">
지금 몇 시지?
</a>
```
마치 http:에 URL 링크가 붙은 것처럼, 브라우저는 현재 문서를 지우고 새로운 문서를 표시한다. 위의 코드에서 반환한 값은 어떤 HTML 태그도 담고 있지 않다. 그러나 링크를 클릭하면, 브라우저는 HTML 문서를 렌더링하듯 코드에서 반환한 값도 렌더링할 것이다.
```
<a href="javascript:alert(new Date().toLocaleTimeString());">
시간 확인 (문서를 덮어쓰지 않음)
</a>

<a href="javascript:void window.open('about:blank');">
open Window
</a>
```

HTMl 문서 외부에서 자바스크립트를 실행할 때 javascript: URL은 유용한 역할을 한다. 작은 자바스크립트 코드 조각을 테스트 할 때 브라우저 주소 창에 javascript: URL을 직접 넣을 수 있다. 하지만 이 방법의 가장 적절한 사용처는 브라우저 북마크 다.

#####웹 브라우저의 북마크는 저장된 URL 이다.
javascript: URL을 북마크하면 작은 자바스크립트를 저장한 셈이고, 이를 **북마클릿** 이라고 한다.
북마클릿은 브라우저의 메뉴나 툴 바에서 손쉽게 실행할 수 있는 작은 프로그램이다.
```
<a href='javascript:
	var e ="", r = "";
    do {
    	e = prompt("Expression: " + e + " \n " + r + " \n ", e);
        try{r="Result:"+eval(e);}
        catch(ex) {r = ex;}
    }while(e);
	void 0;
	'>
Javascript Evaluator
</a>
```

#####자바스크립트 프로그램의 실행
위의 코드들은 하나의 전역 Window 객체를 공유한다. 이 말은 코드들이 같은 Document 객체를 바라보며 같은 전역 함수와 변수를 공유한다는 뜻이고, 새로운 전역 변수나 함수가 정의되면 정의된 후에 작동하는 자바스크립트 코드에서도 이 변수와 함수가 노출된다는 의미다.

자바스크립트의 실행
1.문서 내용을 불러오고 script 요소의 코드를 실행한다. 내장 스크립트와 외부 스크립트를 모두 포함한다.
2.이벤트를 중심으로 비동기 적으로 자바스크립트가 실행된다. 이벤트 핸들러는 대부분 사용자 입력의 응답으로 실행되지만 네트워크 활성화, 시간 경과, 자바스크립트 코드의 에러가 계기가 되기도 한다. (javascript: URL도 이벤트 핸들러의 한 형태다)

이벤트 주도 단계에서 처음 발생하는 이벤트 load 이벤트다. load 이벤트발생은 문서를 모두 불러왔고 수정할 준비가 되었음을 뜻한다. onload 핸들러의 내용은 대부분 문서를 조작하는 일이다.

**defer** 속성을 사용하면 브라우저는 문서를 모두 불러오고 파싱해서 조작할 준비가 끝날 때까지 스크립트 실행을 미룬다.
**async** 속성을 사용하면 스크립트를 다운로드 하는 동안에도 문서 파싱을 계속하고 , 문서 파싱 완료와 관계없이 가급적 빨리 스크립트를 실행한다.

두 속성을 모두 사용하면, 브라우저는 defer 속성은 무시하고 async 송석을 적용한다.
```
<script defer src="deferred.js"></script>
<script async src= "async.js"></script>
```

#####이벤트가 주도하는 자바스크립트

이벤트 핸들러 함수를 등록하는 프로그램을 만든다. 이벤트 핸들러 함수는 등록된 요소에서 이벤트가 발생하면, 즉, 비동기 시점에 호출된다.

예를들어 문서의 구조를 분석하고 도표를 자동으로 생성하는 프로그램을 만든다고 가정하자. 사용자 입력 이벤트를 위한 이벤트 핸들러는 필요 없지만, 문서 호출이 끝났고 만든 도표를 받을 준비가 되었는지를 알기 위해서 onload 이벤트 핸들러를 등록할 것이다.

일반적인 이벤트 형태는 **click, change, load, mouseover, keypress, readystatechange** 같은 이름이 붙는다.

프로그램이 이벤트에 응답하게 하려면 이벤트 핸들러, 이벤트 리스너 경우에 따라서 콜백이라고도 하는 함수를 작성해야 한다.
이벤트가 발생했을 때 적용되도록 함수를 등록한다. 많이 알려진 것처럼, 이벤트 핸들러 등록을 위해 HTML 속성을 사용할 수 있으나 이러면 HTML 내용과 자바스크립트 코드가 뒤섞여서 좋지 않다.
대신, 다른 간단한 방법은 대상 객체의 속성에 자바스크립트 함수를 지정하는 것이다.
```
window.onload = function() {...};
document.getElementById("button1").onclick = function() {...};
function handleResponse() {...}
request.onreadystatechange = handleResponse;
```

이벤트 타깃이 문서 요소일 때는 이벤트가 문서 계층 구조를 따라 상위로 올라가는데, 이를 **버블링** 과정 이라고도 한다.

하나의 이벤트에 여러개의 이벤트 핸들러를 함수를 등록하거나, 동일 객체의 동일 이벤트에 서로 다른 모둘이 이벤트 핸들러를 여러 개 등록하는 데 문제가 없으려면, 다른 이벤트 핸들러 등록 방법을 사용해야 한다.
```
window.addEventListener("load", function() {...}, false);
window.addEventListener("readystatechange" function() {...}, false);

IE8이하 버전에서 사용하는 attachEvent()도 있다.
window.attachEvent("onload", function() {...});
```

#####클라이언트 측 자바스크립트 스레드 모델
클라이언트 측 자바스크립트는 여전히 고정된 단일 스레드인 것처럼 동작한다. 동시 실행이 가능할 때에도, 클라이언트 측 자바스크립트는 다른 스레드가 실행한 것을 탐색할 수 없다.
단일 스레드 실행은 코드를 매우 단순하게 만든다.
두 개의 이벤트 핸들러가 절대로 동시에 실행되지 않는다는 확신속에 코드를 짤수 있다. 지금 수정하려는 문서를 다른 스레드가 동시에 수정하려고 할 수 없음을 확신할 수 있고, 코드를 짤 때 멀티 스레드처럼 **락, 데드락, 경합상태**도 걱정할 필요가 없다.
하지만 단일 스레드 실행은 스크립트와 이벤트 핸들러가 실행되는 동안 사용자 입력에 대한 응답이 중단돼야 한다는 뜻이다. 이것은 자바스크립트 프로그래머에겐 부담인데, 스크립트와 이벤트 핸들러가 너무 오래 실행되면 안 되기 때문이다.

HTML5는 **웹 워커** 라고 하는 관리 가능한 동시성 처리 방식을 제공한다. 웹 워커는 사용자 인터페이스를 멈추지 않고 오래 걸리는 연산을 실행할 수 있는 백그라운드 스레드다. 웹 워커 스레드에서 실행하는 소스는 문서 내용에 접근 권한이 없고, 메인 스레드나 다른 웹 워커와 상태값 공유를 할 수도 없으며, 오직 비동기 이벤트로만 통신이 가능하다.

#####클라이언트 측 자바스크립트 실행 순서
1.웹 브라우저는 document객체를 생성하고 웹 페이지 분석을 시작하는데, HTML 요소와 그 안의 텍스트 내용을 분석해서 Element 객체와 Text 노드를 웹 페이지 문서에 추가한다. 이 때 document.readyState 속성값은 loading 이다.
2.HTML 분석기가 async나 defer 속성이 없는 script 요소와 만나면, 문서에 추가하고 내장 스크립트건 외부 파일이건 구분 없이 실행한다. 이런 스크립트 동기모드로 실행된다. 이런 스크립트는 동기모드로 실행 된다. 그래서 스크립트를 다운로드 하고 실행하는 동안 HTMl 분석기는 멈춘다.
3.HTML 분석기가 async 속성이 지정된 script 요소를 만나면, 스크립트 택스트 다운로드를 시작하고 문서 분석도 계속한다.
4.문서 분석이 완료되면, document.readyState속성 값은 "interactive"로 바뀐다.
5.defer 속성이 있는 스크립트 문서 내에 나타나는 순서대로 실행된다.
6.브라우저는  Document 객체에서 DOMContenLoaded 이벤트를 일으킨다. 이 이벤트는 프로그램 실행 단계가 동기 모드스크립트단계에서 비동기 모드인 이벤트 주도 단계로 옮겨갔다는 신호다.
7.브라우저는 이 시점에서 문서를 완전히 분석했지만, 이미지 등 추가로 불러와야 하는 내용을 기다릴 수 있다. 이런 내용도 모두 불러오고 모든 비동기 스크립트도 불러와서 실행했으면, document.readyState 속성값은 complete로 바뀐다.
8.이 시점부터 이벤트 핸들러는 사용자 입력 이벤트, 네트워크 이벤트, 타이머 만료 등의 응답으로 비동기 호출 된다.

#####호환성 라이브러리
비호환성 문제를 다루는 가장 쉬운 방법은 이 문제를 피해 갈 수 있는 라이브러리를 사용하는 것이다.
HTML페이지 안에 적절한 라이브러리를 추가하고, 이런 강력하고 유용한 메서드들을 모든 브라우저의 기본적인 제공 환경으로 가정하고 다룰 수 있다.
오늘날 jQuery같은 클라이언트 측 자바스크립트 프레임워크를 사용한다. 이런 프레임워크를 필수 요소로 만드는 이유 중 하나는 새로운 클라이언트 측 API를 정의하면서 모든 브라우저에서 호환되도록 구현했기 때문이다.

#####자바스크립트가 할 수 없는 것
악성 코드에 대한 웹 브라우저의 일차적인 방어책은 특정 기능들을 제공하지 않는 것이다. 예를들어, 자바스크립트는 클라이언트 컴퓨터에서 임의로 디렉터리와 파일을 만들거나 지울 수 없다.

클라이언트 측 자바스크립트만으로는 인터넷 상의 일반적인 서버 클라이언트 관계를 구현할 수 없다.

#####동일 출처 정책
동일 출처 정책은 자바스크립트 코드가 웹 콘텐츠와 상호 작용을 할 수 있다는 사실 전반에 걸친 폭넓은 보안 제약 사항이다. 일반적으로 iframe 요소를 포함한 웹 페이지나 새로운 브라우저 창이 열릴때 작동 하는데, 한 창이나 프레임의 코드는 동일 출처 정책의 감독하에 다른 창이나 프레임과 상호작용한다. 다시 말해 자바스크립트는 스크립트를 포함하고 있는 문서와 같은 출처의 문서에 있는 window와 Document 객체의 속성만을 사용할 수 있다.

**해제**
하위 도메인을 여러 개 사용하는 대형 사이트에서는 동일 출처 정책이 문제를 일으킨다.
home.example.com 문서의 스크립트가 developer.example.com에서 불러온 문서의 속성을 읽으려고 하거나, orders.example.com의 스크립트가 catalog.example.com에 있는 무서의 속성을 필요로 할지도 모른다. Document 객체의 doamin 프로퍼티를 사용하면 이런 종류의 멀티 도메인 사이트 문제를 해결할 수 있다. 프로퍼티의 기본값은 문서를 불러온 서버의 호스트 이름이다. 이 속성값을 변경할 수는 있찌만, 기본값의 도메인에서 뒷 부분의 문자열을 규칙에 맞게 사용할 때만 가능하다.
1.두개의 창이나 프레임에서 domain속성이 같은 값으로 지정된 스크립트를 가지고 있다면, 두 창에서는 동일 출처 정책이 해제되고, 상호작용도 가능해진다.
order.example.com과 catalog.example.com에서 불러온 문서끼리 협업하는 스크립트는 두 문서의 document.domain속성을 example.com로 지정하면 출처가 같아지므로 서로 속성을 불러 올 수 있다.
2.현재 만들어지고 있는 출처 간 자원 공유 란 이름의 표준안이다.
3.교차 출처 문서 간 메세지 교환인데, 스크립트의 출처가 달라도 이 문서에서 저 문서로 텍스트 메세지를 전달할 수 있다.

#####크로스 사이트 스크립팅
사이트 공격자가 목표사이트에 HTML 태그나 스크립트를 집어넣는 보안 문제를 일컫는 말이다.
사용자 입력 정보에 포함된 HTML 태그를 제거하는 일종의 방역 작업을 거치지 않은 채, 이 내용을 기반으로 동적으로 문서를 생성한다면 웹 페이지가 교차 사이트 스크립팅 취약해진다. 
```
<script>
var name = decodeURIComponent(window.location.search.substring(1)) || "";
document.write("hello" + name);
</script>
```
URL의 물음표 이후 부분을 가져오는 window.location.search를 사용한다. 문서에 동적으로 내용을 넣기 위해 document.write()를 사용했다.
```
http://www.example.com/greet.html?David
```
다음경우 Hello David 텍스트를 출력한다.
```
http://www.example.com/greet.html?%3Cscript%3Ealert('David')%3C/script%3E
```
%3C,%3E는 꺽쇠 괄호이며 대화상자를 출력하는 간단한 예제이다.
다음과 같이 교차 사이트 스크립팅 공격은 하나 이상의 사이트가 연관된다.
```
http://siteA/greet.html?name-%3Cscript src=siteB/evil.js%3E%3C/script%3E
```

XSS 공격을 막는 일반적인 방법은 동적으로 문서 내용을 생성하기 전에, HTML 태그를 지워 버리는 것이다. 앞에서 본 greet.html 예제는 다음과 같이 script 태그를 둘러 싼 꺽쇠 괄호를 지우는 식으로 개선할 수 있다.
```
name = name.replace(/</g,"<").replace(/>/g, ">");
```

#####클라이언트 측 프레임워크
많은 웹 개발자들이 웹 애플리케이션을 만들기에 유용한 클라이언트 측 프레임 워크 라이브러리를 찾는다. 이런 라이브러리는 브라우저 제작사가 제안한 표준화되고 저작권이 있는 API들 위에서, 클라이언트 측 프로그래밍을 위해 만든 고수준의 새로운 API란 면에서 분명 프레임워크라 볼 수 있다.