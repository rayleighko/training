# 언리얼에서의 C++



이 자료는 [언리얼 공식 문서](http://api.unrealengine.com/KOR/Programming/Introduction/index.html)를 참고해 만들어졌습니다.



### 게임플레이 클래스: Object, Actor, Component

게임플레이 클래스에 대해 파생해 올 수 있는 클래스 유형은 크게 네 가지.

>  UObject, AActor, UActorComponent, UStruct



물론 이 클래스 외에도 파생된 유형을 만들 수는 있지만, 엔진에 내장된 기능이 포함되지는 않을 것이다.



#### 언리얼 오브젝트(UObject)



언리얼 엔진의 기본 구성요소라고 할 수 있다. 이 클래스는 **UClass**와 함께 엔진의 가장 중요한 근간이 되는 서비스를 다수 제공한다. 그 기능은 다음과 같다.



1. 프로퍼티와 메소드의 반영
2. 프로퍼티의 시리얼라이제이션
3. 가비지 컬렉션
4. 이름으로 UObject 찾기
5. 프로퍼티에 환경설정 가능 값
6. 프로페티와 메소드에 네트워킹 지원

> UObject에서 파생되는 각 클래스에는 그에 대한 단독 개체 UClass가 생성되어 클래스 인스턴스에 대한 모든 메타 데이터가 포함된다.

UObject와 UClass의 차이점이라면, UClass는 UObject의 인스턴스가 어떤 모양인지, 어떤 프로퍼티가 시리얼라이제이션, 네트워크 대상인지 등을 설명하는 것이라고 보면 된다. 즉, UObejct에 대한 설명을 포함한다.

그래서 대부분의 개발 상황에서는 UObejct를 직접 파생하기 보다는, AActor나 UActorComponent를 파생하게 된다. 게임플레이 코드를 작성하기 위해 세부적은 UClass/UObject 작동 방식을 알아야 할 필요는 없지만, 이런 시스템이 존재한다는 것만 알아두면 좋다.



#### AActor

AActor는 게임플레이 경험의 일부로 쓸 오브젝트를 말한다. AActor는 디자이너가 레벨에 배치하거나, 게임플레이 시스템을 통해 런타임에 생성하는 것도 가능하다. 레벨에 배치할 수 있는 오브젝트는 전부 이 클래스에서 확장한다고 보면 된다. 그 예는 **AStaticMeshActor**, **ACameraActor**, **APointLight** 등이다. 이들은 앞에 A가 붙어있는 것처럼 엑터를 나타낸다.

AActor는 UObject에서 파생되므로, 기존 섹션에 나열된 '표준 기능 혜택(위에서 언급한 6가지)'을 전부 누릴 수 있다. AActor는 게임플레이 코드(C++, 블루프린트)를 통해 명시적으로 소멸시킬 수도 있고, 소유중인 레벨이 메모리에서 언로드될 때 표준 가비지 컬렉션 메커니즘을 통해 소멸시킬 수 있다. 이는 쉽게 말하면 프로그래머가 직접 제거하거나 가바지 컬렉션에 의해 자동적으로 소멸시킬 수 있는 것이다.



> 이밖에도 AActor는 네트워크  지원을 필요로 하는 AActor에 소유된 UActorComponent에 대해서도 정보를 배포할 수 있다. 



AActor에는 별도의 작동방식이 존재하는데, 이를 상속을 통한 전문화라고 한다. 또한, UActorComponent 계층구조에 대한 컨테이너 역할도 수행하는데, 이를 구성을 통한 전문화라고 한다. 

구성을 통한 전문화는 AActor의 RootComponent 멤버를 통해 이루어지는데, 여기에는 하나의 UActorComponent가 들어있으며, 차례대로 다른 여러 컴포넌트가 담긴다. 그리고 AActor를 레벨에 배치하기 전, AActor는 반드시 최소 하나의 USceneComponent가 들어있어야 한다. USceneComponent에는 AActor에 대한 이동, 회전, 스케일이 들어있따.



AActor에는 AActor의 lifecycle 도중 호출할 수 있는 이벤트 시리즈가 있다. 아래 목록은 단순화시킨 이벤트 세트로 그 수명을 나타낸 것이다.

1. BeginPlay - 오브젝트가 게임플레이에 처음 등장했을 때 호출된다.
2. Tick - 지속적으로 이루어지는 작업을 하기 위해 프레임 당 한 번 호출된다.
3.  EndPlay - 오브젝트가 게임플레이 공간을 떠날 때 호출된다.



#### Runtime lifecycle

앞서 AActor의 lifecycle을 간략하게 살펴보았다. 레벨에 배치된 액터의 경우, 그 수명을 이해하는 것은 어렵지 않다. 액터가 등장하기 시작하면 로드하고, 레벨이 언로드되면 액터가 소멸하면 되기 때문이다. 그러면 레벨에 배치되지 않은, 런타임 동안의 엑터 생성 및 소멸 프로세스는 어떨까?

언리얼 엔진에서는 런타임 스폰 시 AActor 생성을 호출한다. 액터 스폰은 게임에서 일반 오브젝트 생성시보다 약간 더 복잡하다. 그렇기 때문에 엑터의 스폰을 전담하는 메소드를 만들었는데, 바로 UWorld::SpawnActor()이다. 그 액터 스폰에 성공하면 BeginPlay() 메소드가 호출되고, 다음 프레임에 Tick()이 잇따르게 된다. 



만약 엑터가 라이프사이클(수명) 이상으로 살아남게 되면, Destroy() 함수를 호출하여 소멸시킬 수 있다. 그 프로세스 도중 EndPlay()가 호출되는데, 여기서 소멸 관련 커스텀 로직을 짤 수 있다. 이외에도 Lifespan 멤버를 사용해 엑터가 얼마나 오래 존재하는가를 제어할 수 있다. 오브젝트의 생성자 또는 런타임에 따른 코드 안에 기간을 설정할 수 있고, 그 기간이 만료되면, 엑터는 자동으로 스스로에 대해 Destory() 함수를 호출하게 된다.



#### UActorComponent

UactorComponent에는 별도의 작동방식이 내장되어 있으며, 보통 비주얼 메시, 파티클 이펙트, 카메라 시점 등 AActor의 여러 유형에 공유되는 기능을 담당한다. AActor는 보통게임의 전반적인 규칙에 관계된 일반적인 수준의 목표가 주어지는 반면, UActorComponent는 보통 그 일반적인 수준의 목표를 보조하는 개별 작업을 수행한다. 컴포넌트는 다른 컴포넌트에 붙일 수도 있고, 액터의 루트 컴포넌트가 될 수도 있다. 컴포넌트는 오직 하나의 부모 컴포넌트 또는 엑터에만 붙일 수 있으나, 자신에게는 다수의 자손 컴포넌트를 붙일 수도 있다.



> 자손 컴포넌트는 부모 컴포넌트를 기준으로 한 위치, 회전, 스케일 값을 갖는다.



이를 풀어 설명하면 엑터는 "이게 뭐지?"라는 질문에 대한 답을 해주고, 컴포넌트는 "이게 뭘로 만들어졌지?"라는 물음에 답을 해준다고 볼 수 있다.



* RootComponent - AActor의 컴포넌트 트리 내 최상위 컴포넌트를 담는 AActor 멤버를 말한다.
* Ticking - 소유한 AActor의 Tick() 일부분으로, 반복되는 컴포넌트를 말한다.



#### 일인칭 캐릭터 분석

위의 몇몇 섹션은 이론적인 부분만 다뤘지 실제로 살펴보지는 않았다. AActor와 그 UActorComponent 사이의 관계를 눈으로 보기 위해, First Person(일인칭) 템플릿을 기반으로 새 프로젝트를 만들었을 때 생성되는 블루프린트를 파 보도록 하자.



![image alt text](http://api.unrealengine.com/images/Programming/Introduction/image_14.jpg)



위 그림은 FirstPersonCharacter 액터의 Component 트리이다. RootComponent는 CapsuleComponent이고, CapsuleComponent에는 ArrowComponent, MeshComponent, FirstPersonCameraComponent가 붙어있다. 가장 말단에 붙어있는 컴포넌트는 Mesh1P이고, 부모는 FirstPersonCameraComponent, 즉 일인칭 카메라 기준 일인칭 메시를 의미한다.



시각적으로 이 컴포넌트 트리는 아래의 그림과 같은데, Mesh 컴포넌트를 제외한 모든 컴포넌트가 3D 공간에 보인다.



![image alt text](http://api.unrealengine.com/images/Programming/Introduction/image_15.jpg)



이 컴포넌트 트리는 하나의 엑터 클래스에 붙어있다. 이 예제와 같이, 상속과 구성 양쪽을 통해 복잡한 게임플레이 오브젝트를 만들 수 있다. 기존 AActor 또는 UActorComponent를 커스터마이징 할 때는 상속을, 여러가지 다양한 AActor 유형에 함수 기능을 공유시킬 때는 구성을 사용한다.



#### UStruct

Ustruct를 사용하기 위해서는, 특정 클래스를 확장할 필요 없이, 그냥 구조체에 USTRUCT() 마킹을 해주면 빌드 툴이 알아서 바탕 작업을 진행한다. UObject와 달리, UStruct는 가비지 컬렉션 대상이 아니다. 그에 대한 동적 인스턴스를 생성한 경우, 그 수명을 직접 관리해 줘야 한다. 보통 UStruct는 언리얼 에디터 내 편집, 블루프린트 조작, 시리얼라이제이션, 네트워크 등 UObject 리플렉션이 지원되는 일반적인 예전 데이터 유형을 모아놓는 용도로 사용한다.

게임플레이 클래스 생성 시 사용되는 기본적인 계층구조에 대해 이야기를 나눴으니, 다시 한 번 게임플레이 클래스에 대한 상세 정보를 확인할 수도, 런처에서 받을 수 있는 샘플에서 추가 정보를 확인할 수도 있고, 계속해서 게임 제작을 위한 C++ 기능을 더욱 깊이 파내려가 볼 수도 있다.